<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>详解prototype与__proto__ · Tit1e</title><meta name="description" content="详解prototype与__proto__ - Tit1e"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/Tit1e/atom.xml" title="Tit1e"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">主页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">过往</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">订阅</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">详解prototype与__proto__</h1><div class="post-info">Nov 28, 2016</div><div class="post-content"><h3 id="prototype与-proto-详解"><a href="#prototype与-proto-详解" class="headerlink" title="prototype与__proto__详解"></a><code>prototype</code>与<code>__proto__</code>详解</h3><p><code>prototype</code>和<code>__proto__</code>在JS中一直是一个比较头痛的东西。JS的继承是基于原型的继承。</p>
<p>在JavaScript中，我们创建一个函数a(就是声明一个函数), 那么浏览器就会在内存中创建一个对象b，而且每个函数都默认会有一个属性 <code>prototype</code> 指向了这个对象( 即：<code>prototype</code>的属性的值是这个对象 )。这个对象b就是函数a的原型对象，简称函数的原型。这个原型对象b 默认会有一个属性<code>constructor</code>指向了这个函数a ( 意思就是说：<code>constructor</code>属性的值是函数a)。</p>
<p>代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">a;<span class="comment">//function a()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个函数a，在chrome控制台中打印这个函数，显示的就是这个函数本身，</span></span><br><span class="line"><span class="comment">//但实际上这个函数有一个隐藏属性prototype，并且prototype是一个对象，</span></span><br><span class="line"><span class="comment">//prototype中还有一个constructor属性，constructor指向构造函数（这里指向a函数）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以实际上a函数的结构是这个样子的：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    prototype:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:function a()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>当使用构造函数a创建对象b后，b对象会自动添加一个不可见的<code>prototype</code>属性，这个属性指向构造方法的原型对象，即<code>a.prototype</code>。但是个别浏览器（chrome、火狐支持（其它浏览器暂不清楚），IE不支持）提供了对这个属性的访问方式，即<code>__proto__</code>。<br>代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> a();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时b对象的结构：</span></span><br><span class="line">b = &#123;</span><br><span class="line">    __proto__:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:function a()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype <span class="comment">//undefined</span></span><br><span class="line">b.__proto__ <span class="comment">//Object &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>所以用a构造函数创建的对象原型都指向<code>a.prototype</code>，因此修改<code>a.prototype</code>，通过a函数创建的对象也会受到影响。<br>代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">a.prototype.sex = <span class="string">"boy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的a函数结构：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    prototype:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:function a()&#123;&#125;,</span><br><span class="line">        sex:<span class="string">"boy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时b对象的结构：</span></span><br><span class="line">b = &#123;</span><br><span class="line">    __proto__:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:function a()&#123;&#125;,</span><br><span class="line">        sex:<span class="string">"boy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于b函数的原型指向a.prototype，因此b.__proto__.sex也也可以访问sex属性</span></span><br><span class="line">b.__proto__.sex <span class="comment">//"boy"</span></span><br><span class="line"><span class="comment">//需要说明的是，如果我们访问一个对象的属性，如果在对象中找到了属性，</span></span><br><span class="line"><span class="comment">//就会直接返回，如果没有找到则会去对象指向的原型中找，如果原型中找到，</span></span><br><span class="line"><span class="comment">//则返回，因此，b.sex也可以访问到sex属性</span></span><br><span class="line">b.sex <span class="comment">//"boy"</span></span><br><span class="line"><span class="comment">//如果向b对象添加一个sex属性，那么新添加的sex属性会屏蔽原型中的sex属性</span></span><br><span class="line">b.sex = <span class="string">"girl"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时b对象的结构：</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    sex:<span class="string">"girl"</span>,</span><br><span class="line">    __proto__:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:function a()&#123;&#125;,</span><br><span class="line">        sex:<span class="string">"boy"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.sex <span class="comment">//"girl"</span></span><br><span class="line"><span class="comment">//这个时候如果要获取原型中的sex属性需要通过b.__proto__.sex</span></span><br><span class="line">b.__proto__.sex <span class="comment">//"boy"</span></span><br></pre></td></tr></table></figure></p>
<p>因为<code>prototype</code>可以修改，所以你也可以根据需要指定新的对象为a函数的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a.prototype = &#123;</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="string">"19"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的a函数结构：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    prototype:&#123;</span><br><span class="line">        name:<span class="string">"jack"</span>,</span><br><span class="line">        age:<span class="string">"19"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时你会发现默认指向构造函数的constructor属性没有了。</span></span><br><span class="line"><span class="comment">//如果你需要constructor重新指向构造函数，则需要手动添加。</span></span><br><span class="line">a.prototype.constructor = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的a函数结构：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    prototype:&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:a;</span><br><span class="line">        name:"jack",</span><br><span class="line">        age:"19"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.prototype.<span class="keyword">constructor</span> //function a()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hasOwnProperty方法"><a href="#hasOwnProperty方法" class="headerlink" title="hasOwnProperty方法"></a>hasOwnProperty方法</h3><p>从上面我们已经知道了一个对象的属性可以来自自身也可以来自原型，那么怎么区分呢？<code>hasOwnProperty</code>方法就是用来区分某个属性是否来自自身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">b.sex <span class="comment">//"girl" //这是我们自己添加的属性，不是从原型中继承过来的</span></span><br><span class="line">b.hasOwnProperty(<span class="string">"sex"</span>) <span class="comment">//true</span></span><br><span class="line">b.__proto__.name <span class="comment">//undefined 为什么这里会出现这种情况呢？</span></span><br><span class="line"><span class="comment">//原因是之前执行了：</span></span><br><span class="line">a.prototype = &#123;</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="string">"19"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个操作将整个prototype对象替换了，因此现在的prototype已经不是之前的prototype了，</span></span><br><span class="line"><span class="comment">//而b还是指向之前的prototype，而之前的prototype中没有name属性，因此返回undefined。</span></span><br><span class="line"><span class="comment">//如果此时再创建一个c对象：</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> a()</span><br><span class="line">c.__proto__.name <span class="comment">//"jack"</span></span><br><span class="line"><span class="comment">//此时创建的对象原型指向新的a.prototype属性，因此可以访问到name属性。</span></span><br><span class="line"><span class="comment">//那么怎样能让b的原型重新指向a.prototype呢？</span></span><br><span class="line"><span class="comment">//只要执行：</span></span><br><span class="line">b.__proto__ = a.prototype</span><br><span class="line">b.__proto__.name <span class="comment">//"jack"这样b就可以访问到新的属性了。</span></span><br><span class="line"><span class="comment">//回归原题</span></span><br><span class="line">b.hasOwnProperty(<span class="string">"name"</span>) <span class="comment">//false 因为name在原型中，所以返回false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>in操作符用来判断一个属性是否存在于这个对象中。查找顺序为现在对象自身中查找，自身找不到就到原型中查找，所以只要对象的原型中存在属性，<code>in</code>操作都返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sex"</span> <span class="keyword">in</span> b <span class="comment">//true</span></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> b <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="组合原型模型和构造函数模型创建对象"><a href="#组合原型模型和构造函数模型创建对象" class="headerlink" title="组合原型模型和构造函数模型创建对象"></a>组合原型模型和构造函数模型创建对象</h3><p>在构造函数中添加的属性和方法，每个对象都有自己独有的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"李四"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"吃完东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//每个对象都会有不同的方法</span></span><br><span class="line">alert(p1.eat === p2.eat); <span class="comment">//fasle</span></span><br></pre></td></tr></table></figure></p>
<p>解决方法是将方法提取出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"李四"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = eat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"吃完东西"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//因为eat属性都是赋值的同一个函数，所以是true</span></span><br><span class="line">alert(p1.eat === p2.eat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>但是上面的这种解决方法具有致命的缺陷：封装性太差。eat函数是暴露在全局中的。<br>原型模式适合封装方法，构造函数模式适合封装属性，综合两种模式的优点就有了组合模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构造方法内部封装属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在原型对象内封装方法</span></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"爱吃"</span> + food);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = <span class="function"><span class="keyword">function</span> (<span class="params">playName</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"爱玩"</span> + playName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>);</span><br><span class="line">p1.eat(<span class="string">"苹果"</span>);</span><br><span class="line">p2.eat(<span class="string">"香蕉"</span>);</span><br><span class="line">p1.play(<span class="string">"志玲"</span>);</span><br><span class="line">p2.play(<span class="string">"凤姐"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式创建对象"><a href="#动态原型模式创建对象" class="headerlink" title="动态原型模式创建对象"></a>动态原型模式创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法内部封装属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每个对象都添加自己的属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="comment">//判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象，</span></span><br><span class="line">        <span class="comment">//则把这个funcion添加到原型中。</span></span><br><span class="line">        <span class="comment">//如果是function，则代表原型中已经有了这个方法，则不需要再添加。</span></span><br><span class="line">        <span class="comment">//perfect！完美解决了性能和代码的封装问题。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.eat !== <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name + <span class="string">" 在吃"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"志玲"</span>, <span class="number">40</span>);</span><br><span class="line">p1.eat();</span><br></pre></td></tr></table></figure>
<p>内容参考：<a href="http://blog.csdn.net/u012468376/article/details/53121081" target="_blank" rel="noopener">http://blog.csdn.net/u012468376/article/details/53121081</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/28/19-hello-2017/" class="prev">上一篇</a><a href="/2016/11/13/16-not-book-review/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2020 <a href="https://github.com/Tit1e" target="_blank">Tit1e</a>, powered by <a href="https://github.com/Tit1e/hexo-theme-simple" target="_blank">hexo-theme-simple</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>