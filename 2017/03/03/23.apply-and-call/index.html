<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> apply和call的区别 · I'm Tit1e</title><meta name="description" content="apply和call的区别 - Tit1e"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="I'm Tit1e"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">apply和call的区别</h1><div class="post-info">2017年3月3日</div><div class="post-content"><p>今天看原生js的时候看到了<code>call</code>和<code>apply</code>,对这两个方法印象不是很清楚，只记得这两个方法很相似，作用大概是让A通过<code>call</code>或<code>apply</code>能够调用B独有的方法，但是具体的使用方法已经模糊，所以网上查了资料重新理了一遍。</p>
<p>先看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Createpeople</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line">Createpeople.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello!My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Amy = <span class="keyword">new</span> Createpeople(<span class="string">'Amy'</span>, <span class="number">18</span>);</div><div class="line">Amy.say();  <span class="comment">//Hello!My name is Amy</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> john = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'john'</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">20</span></div><div class="line">        &#125;</div><div class="line">john.say();  <span class="comment">//john.say is not a function</span></div><div class="line">Amy.say.call(john);  <span class="comment">//Hello!My name is john</span></div><div class="line">Amy.say.apply(john);  <span class="comment">//Hello!My name is john</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><code>Createpeople</code>是一个构造函数，并且在原型中写入了一个<code>say</code>方法。我们用<code>Createpeople</code>创造了<code>Amy</code>对象，所以<code>Amy</code>理所当然地可以调用<code>say</code>方法。而<code>john</code>是我们手动创建的一个对象，所以<code>john</code>调用<code>say</code>方法理所应当会报错。那么如何让<code>john</code>能够调用<code>say</code>方法呢？那就要通过<code>call</code>方法或<code>apply</code>方法了。通过<code>Amy.say.call(john)</code>，从输出结果来看<code>john</code>正确的调用了<code>say</code>方法,<code>apply</code>也同样。</p>
<p>为什么呢？原因就在于<code>call</code>和<code>apply</code>在调用的时候会传入一个调用对象，即<code>this</code>，它们能将原来不指向传入对象的函数的<code>this</code>强行指向传入对象。可能这样说不是很明白，下面我来解释一下：</p>
<p>在其他方法执行的时候会默认传入一个调用对象，比如在<code>Amy</code>调用<code>say</code>方法的时候，默认传入的调用对象为<code>Amy</code>，<code>say</code>方法作为<code>Amy</code>的一部分正常情况下因为正常情况下<code>this</code>只能指向<code>Amy</code>，但是通过<code>call</code>和<code>apply</code>方法能让<code>say</code>方法的<code>this</code>强行指向传入的<code>john</code>，<code>this</code>变成了<code>john</code>，理所当然，<code>say</code>方法就能正常执行了。</p>
<h4 id="那么call和apply有什么区别呢？"><a href="#那么call和apply有什么区别呢？" class="headerlink" title="那么call和apply有什么区别呢？"></a><strong>那么<code>call</code>和<code>apply</code>有什么区别呢？</strong></h4><p>区别在于<strong>参数</strong>的传入方式不同。<br>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(a + b);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">c, d</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(c - d);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">sub.apply(add, [<span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">//-1</span></div><div class="line">sub.call(add, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//-1</span></div><div class="line">add.apply(sub, [<span class="number">1</span>, <span class="number">2</span>]);  <span class="comment">//3</span></div><div class="line">add.call(sub, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p><code>call</code>方法参数是一个一个传的，而<code>apply</code>方法，除了<code>this</code>，其他参数是用数组的方式传的。<br>由于<code>apply</code>传数组这个特点，我们可以很方便地对数组进行某些操作，比如拼接两个数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> list2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line">[].push.apply(list1, list2);  <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(list1);  <span class="comment">//[1, 2, 3, 4, 5, 6]</span></div></pre></td></tr></table></figure></p>
<p><code>push</code>方法可以传很多参数，但是不能传数组，正常情况下凭借数组只能够通过循环一个一个添加，但是<code>apply</code>正好需要把多个传入的参数打包成数组，所以正好满足了条件。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/04/24.jsNote/" class="prev">PREV</a><a href="/2017/03/03/22.code_majorization/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Tit1e</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>